
0404
如果分行写函数的参数的话，函数右括号必须在最后一个参数后面而不能另起一行
把:8080改成127.0.1:8080，这样就不需要确认是否允许通过防火墙了
着手做房间内websocket通信的后端
ws通信的话，主要用的是[]bytes
注意client或者说网页端即使作为发送者，也还是要接受后端返回的结果，也就是不区分发送者的身份

0405
格式化字符串还是fmt方便，免去了int转成字符串的烦恼，写格式也舒服得多

现在的问题是，游戏循环是主动接受还是回调响应
如果是主动询问的话，那么主要阶段的各项操作可能要询问两次，不是很行（，当然也可以0-8这样子把所有操作都包括上
前后端的ws通信大概完成了，至于游戏开始时的数据配置还是用gin通过json传递吧，不然用ws有点麻烦

0406
但是在这里有可能涉及到前端的界面，有点麻烦

0522
主要以后端也就是go为主吧，先把游戏逻辑理清，用命令行去模拟前端的操作

0527
考虑把输入和输出事件处理分别单独作为一个接口

0528
那么对于输入的话，考虑到都是点击触发的，所以就没有所谓的先选操作后选索引的说法了，所以，直接前后端同时进行（


0708
开始设计结构到json的转换，也就是开始和前端衔接
现在还是以最简单的方式去解决问题，不要想太多
原来json有标准的转换函数接口啊，不需要自己想函数名了（
如果自定义json编码的话，会出现反斜杠\，单纯设置json标签的话就不会，难顶
因为在game里面import json包就好了，懒得去别的包import了。统一设置比较好
想了想，也就游戏开始时传递json数据，还是简单起见吧（，瞬间舒服了，大道至简，小小流量可笑可笑（
直接在中间结构返回下面结构的json就可以省去中间的字段了，爽

0709
要判断字典里面是否存在某个键，需要用if-ok方法，如果获取一个不存在的键的对应值，将返回默认值

0710
至于获取帮手的费用，以及整理效果的弃牌，要不在前端处理吧？但是实现起来似乎有点难，主要是我不熟悉js，要不交给AI吧（
还有丢弃手牌是由hand类执行的，好像不好发送通知，看来还是得再套一个game类的方法
要不记录一下需要发通知的操作吧（
输入和输出的接口是定义在model类里面的，但是实际实现是在game-process类里面的，这就是好处，毕竟游戏类需要什么还是自己知道，别人需要实现你的接口

0804
总之大纲可以列，但是路要一步一步走，接口的函数还是一个一个实现好
目前有两个主要的包，model存放游戏的逻辑，controler实现控制游戏进行的输入和输出，由model提供对外的输入和输出接口，而controler实现该接口，然后实例化时传进去就好了

我们先简化后端的websocket，让它只返回布尔值，然后测试前端的变化，完成后再修改后端的实现
麻了，websocket包的代码我又看不懂了，给它写写注释，熟悉一下
至于叫hub还是lobby，我觉得无所谓，按照原来的hub吧。不对，这个hub实际是相当于room的，有点难受，当然先按照最简单的hub作为一个游戏房间来做吧
好像一个包下可以有多个init函数，多次初始化

0806
似乎用go可以同时开两个端口的服务，不过有点没必要。一个端口管发送整个游戏的数据，另一个用来建立websocket

0824
现在看来，什么输入输出接口似乎并不重要，因为发送和接受都是基于channel的字节数组通信了，初始化game的时候将这两个发送和接受的管道传进去就好

希望能把websocket的建立集中到gin的设置中，这样就不需要两个go并发了
也许Hub需要不止两个channel，其中两个用来和client通信，再两个与game通信，有没有办法整合起来呢？因为client可以添加用户索引

弄了半天，以为接口里面可以定义成员了，原来http.ResponseWriter是一个接口，gin.ResponseWriter是实现了它的一个更高级接口，可以直接替换它
接下来只用一位玩家进行测试，状态效果没实现的就先不管了
询问某一区域就用a开头为代码，然后在前端做一个集合
我觉得应该做一个函数，专门把很多个int转成byte

没想到Game类竟然只import一个fmt包，令人感叹，大道至简（不是
还有卡堆是有卡组，展示区，弃牌区三个部分的，我们一般用display这部分，
字符串即使有多位，也可以一个[]byte将它全部转化

后面进行元素和符卡的获取以及回合结束的通信

0827
才发现手牌支付资源的方法并未完成，而且Game类并不知道你丢弃了那几张
算了，按照使用频率给点击状态编码吧，不然很烦（，其实选择玩家这种操作很少用得到了

如果要做一个不断接受前端传来的信息的话，就无法区分是事件还是过程中的选择。所以又要额外开一个通道，用来让函数处理过程中因等待值而阻塞时，接受从前端传来的消息。
所以是否让一个进程不断循环进行游戏流程比较合理，这样所有前端传来的都让它接受来处理
而且给符卡支付费用的通信还没搞好，难顶
不是很懂，为什么更换状态要设置界面？大概是因为已经统一到获取符卡流程里面所以不需要单独发送信息了这个意思吧（
想写个一步支付符卡费用的函数，想了想还是算了，逐张删除好了
不是很懂，会不会出现等待接受者得到的不是意向值的情况，理论上这就需要当需要询问所有玩家时逐个询问了
现在就是，越想越觉得复杂，难受
为了搞这游戏开了很多个协程，值得吗（
game类一个接受的，hub两个接受和发送，每个client也都有2个
是否是一种滥用呢（
坏了，按现在的想法，操作码0废掉了
我觉得你还是不要急着写好，一个一个测试，不然要是现在出错了，写的都得改

麻了，接受游戏数据之前好好的，现在出一堆问题，哦，原来是多了一个人导致的，删掉就啥事都没了
好了，现在是获取元素出错，明天看看

0828
草，原来byte转int是直接用ascll码的，48就是0，现在才发现
甚至switch一个byte的case可以用'0'或者48，

0901
测试三个事情，
一是map里面直接传入一个结构能不能自动转成键值对
比较好的解决方法是定义一个新结构体对其编码
二是字符串会怎么转成byte数组
如果能转成ascll就转，即用一个byte去表示，中文就会用3个byte去表示
三是能不能一次性通知完丢弃的手牌
这个简单，字符串划分一下就好

我还是不懂，后端用byte数组，前端却是字符串，令人疑惑

0901
接下来测试获取符卡
如果以后接受玩家的选择都是在某一函数内进行的话，开头的a能不能去掉
我也不知道int忽然凭空变成一个int32，而且int32转成byte不需要加48，难顶，基础不牢是这样的
考虑到以后会有中文的情况，前后端都用string类型吧。
还有前端还是需要按行分隔，不然虽然是每次都是close函数一个一个发送，但是实际上却是每一行合在一块发送的，还是得分行处理

妈的，终于他妈的能单人循环了，而且基本操作都没问题了，好了，项目告一段落了，要完善还是得花很多时间的，唉

wc -l */*.go
   42 controler/command_input.go
  122 controler/game_process.go
   43 controler/input.go
    6 controler/output.go
   11 controler/process_test.go
  115 controler/show.go
   85 controler/show_test.go
    9 controler/variable.go
   81 controler/webConnect.go
   10 model/card.go
  130 model/card_test.go
  158 model/cardDeck.go
   40 model/deck.go
   34 model/element.go
  301 model/game.go
  120 model/handCard.go
   71 model/handCard_test.go
   28 model/helper.go
   59 model/IO_interface.go
  152 model/json_test.go
   96 model/player.go
   16 model/player_test.go
   65 model/playerAction.go
   58 model/playerAction_test.go
   26 model/publicValue.go
   29 model/spellCard.go
   82 model/state.go
   20 model/state_test.go
   43 util/byteUtil.go
   38 util/byteUtil_test.go
   34 wsConn/byte_test.go
  200 wsConn/client.go
   84 wsConn/home.go
  172 wsConn/hub.go
 2580 total

 86 elementCard.vue
   69 elementCard_test.vue
   38 game.vue
  545 game_depth_one.vue
  119 gameState.vue
  113 handCard.vue
   69 handCard_test.vue
  210 playerFrame.vue
   80 playerFrame_test.vue
   88 spellCard.vue
   64 spellCard_test.vue
    3 tips.d.ts
   22 tipsText.js
   67 ws.vue
 1573 total


 0908
 在游戏开始后，向各个玩家发送其编号
 主要操作做完了，但是其实还有很多小操作需要发送，
 比如获取帮手后的结束阶段抽一张，（然而现在也没做帮手系统啊